verbosity=0;

//,---------------------------------------------------------------------
// Circle mesh
//`---------------------------------------------------------------------
// real R=1.5;
real R=2;
border Gamma(t=0, 2*pi) { x=R*cos(t);  y=R*sin(t); };
int nx = 1600;
mesh Th = buildmesh(Gamma(nx));
//,---------------------------------------------------------------------
// Square mesh
//`---------------------------------------------------------------------
// int nx = 30;
// mesh Th = square(nx, nx, [4*x-2, 4*y-2]);

// Unknown and test functions
fespace Uh(Th, P1);
Uh u, ub, u0;
Uh u0s, u0r; // u0^s, u0^r

fespace Vh(Th, P1);
Vh v, vb, v0;
fespace Wh(Th, P1);
Vh w, wb, w0;

//,---------------------------------------------------------------------
//| Time parameters
//`---------------------------------------------------------------------
real t = 0;
int niter = 250;
real dt = 1.e-3;

real tau=1; // tau=0 => elliptic repulsion, tau=1 => parabolic repulsion
bool forcePositivity=false;

//,---------------------------------------------------------------------
//| Keller-Segel data
//`---------------------------------------------------------------------
// real k0=1, k1=0.2, k2=1, k3=0.1, k4=1;
real ChiAttraction=1,    XiRepulsion=1;
real alpha=1, beta=1, gamma=1, delta=1;
real r=1, s=1.7;

// real alpha=30, x0=0.3, y0=0.3;
real C0=20, C1=30, x0=0.0, y0=0.0;
real infU = 2;
func initialUGaussian = infU + C0*exp( -C1*( (x-x0)^2 + (y-y0)^2 ) );
func initialURiemann = x<0;
u0 = initialUGaussian;
v0 = 0.5*u0;
w0 = 0.5*u0;

// x0 = 1;
// v0 = infU + C0*exp( -C1*( (x-x0)^2 + (y-y0)^2 ) );
// x0 = -1;
// w0 = infU + C0*exp( -C1*( (x-x0)^2 + (y-y0)^2 ) );

// func initialU = 1.15*exp(-x^2-y^2)*(4-x^2)^2*(4-y^2)^2;
// func initialV = 0.55*exp(-x^2-y^2)*(4-x^2)^2*(4-y^2)^2;
// u0 = initialU;
// v0 = initialV;

real integralU0=int2d(Th)(u0);
cout <<"La integral del dato inicial es "<< integralU0 << "(4*pi=" << 4*pi << ")" << endl;

string testName = "KS_" +
  "dt:" + dt + "_nx:" + nx + "_ChiAttraction=" + ChiAttraction + "_XiRepulsion=" + XiRepulsion;
  // "_k0" + k0 + "_k1:" + k1 + "_k2:" + k2 + "_k3:" + k3 + "_k4:" + k4;
cout << "Running test " << testName << endl;

//,---------------------------------------------------------------------
//| Variational problems
//`---------------------------------------------------------------------

// Macros..............................................................>
macro grad(u) [ dx(u), dy(u) ] // End of Macro
  ; // for emacs :)
macro div(u,v) ( dx(u) + dy(v) ) // End of Macro
  ; // for emacs :)

// Keller Segel problem / u
problem KSAttRepU(u,ub)=
  int2d(Th)( u*ub/dt + grad(u)'*grad(ub)
	     - ChiAttraction*u*grad(v)'*grad(ub) // Attractive chemotaxis
	     + XiRepulsion*u*grad(w)'*grad(ub) // Repulsive chemotaxis
	     )
  + int2d(Th)( - u0*ub/dt );

// Keller Segel problem / v
problem KSAttRepV(v,vb)=
  int2d(Th)( v*vb/dt + grad(v)'*grad(vb) + beta*v*vb )
  + int2d(Th)( - alpha*u0s*vb
	       - v0*vb/dt );

// Keller Segel problem / w
problem KSAttRepW(w,wb)=
  int2d(Th)( tau*w*wb/dt + grad(w)'*grad(wb) + delta*w*wb )
  + int2d(Th)( - gamma*u0r*wb
	       - tau*w0*wb/dt );

// Time loop ###################################################

for (int k=1; k<=niter; k++) {
  t=t+dt;
  cout << "iter = " << k << "\t (t = " << t << ")" << endl;

  u0s = pow(u0, s);
  KSAttRepV; // Compute v
  if(forcePositivity) { v = max(0, v); }

  u0r = pow(u0, r);
  KSAttRepW; // Compute w
  if(forcePositivity) { w = max(0, w); }

  KSAttRepU; // Compute u from u,v
  if(forcePositivity) { u = max(0, u); }

  // solve Problem(u, ub)=
  //   int2d(Th)(u*ub)
  //   - int2d(Th)(1*ub);

  bool printResults = true; if(printResults) {
    real uMax = u[].max; real uMin=u[].min;
    real vMax = v[].max; real vMin=v[].min;
    real wMax = w[].max; real wMin=w[].min;
    cout << "  max(u) = " << uMax << "  min(u) = " << uMin
  	 << (uMin<0 ? " ...---... u: Positivity broken!!!" : "") << endl;
    if(uMax>1.e+10) {
      cout << "BLOW UP FOUND!!" << endl;
      break;
    }
    cout << "  max(v) = " << vMax << "  min(v) = " << vMin
  	 << (vMin<0 ? " ...---... v: Positivity broken!!!" : "") << endl;
    cout << "  max(w) = " << wMax << "  min(w) = " << wMin
  	 << (wMin<0 ? " ...---... w: Positivity broken!!!" : "") << endl;
    real uInt = int2d(Th)(u); real vInt = int2d(Th)(v); real wInt = int2d(Th)(w);
    u0r = pow(u,r);
    real w0Int = int2d(Th)(w0);
    cout << "    w0Int:" << w0Int << endl;
    real residuo = tau*(int2d(Th)(w)-int2d(Th)(w0))/dt + delta*wInt - gamma*int2d(Th)(u0r);
    cout << "  int_Th(u) = " << uInt << "  int_Th(v) = " << vInt
  	 << "  int_Th(w) = " << wInt << endl;
    cout << "  inf(v0)*exp(-beta *t) = " << infU*exp(-beta*t) << endl;
    cout << "  delta*int(w) - gamma*int(u^r) " << residuo << endl;
  }

  bool plotResults = true; if(plotResults) {
    plot(u, cmm="U", value=1, fill=1, dim=3, wait=1);
    plot(v, cmm="V", value=1, fill=1, dim=3, wait=1);
    plot(w, cmm="W", value=1, fill=1, dim=3, wait=1);
  }

  bool saveToVTK=false; if(saveToVTK) {
    load "iovtk";
    string vtkFile="/tmp/" + testName + ".vtk";
    int[int] vtkOrder=[0];
    savevtk(vtkFile, Th, u, v, w, dataname="u v w", order=vtkOrder);
  }

  u0 = u;  // Prepare next iteration
  // u0s = pow(u0, 0.2);
  v0 = v;
  if(tau != 0) { w0 = w; }

 }
